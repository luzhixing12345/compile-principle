
# 数据流分析

## 到达-定值

位向量

PRSV 没有被修改的

GEN 定义的

out 表示可以离开基本块时仍存在的定值, in 表示在进入基本块时就存在的定值

$out[i] = GEN[i] \vee [in[i] \wedge PRSV[i]]$

当前基本块新的定值 + ( 进入基本块存在的 且 没有被修改的 )

$in[i] = \bigvee\limits_{j \in Pred[i]} out[j]$

所有基本块前驱节点的 out 的集合构成了当前基本块的 in 的集合

## 活跃变量分析

**如果存在着一条通向出口的路径, 在此路径上其值的使用先于对他的重新定义**, 那么我们称这个变量是**活跃的[live]**, 如果不存在则为**死去的[dead]**

> 活跃变量分析在 图着色寄存器分配 和 死代码消除 方面很有用

out 表示可以离开基本块时活跃的定值, in 表示在进入基本块时活跃的定值

use 使用, **在一个基本块内先定值后使用不算使用**

def 定值

$in[i] = (out[i] - def[i]) \cup use[i]$

(离开基本块时仍然活跃的变量 且 不是在基本块内被新定值的) + 基本块内被使用的

$out[i] = \bigvee\limits_{j\in succ[i]} in[j]$

从后往前算

## 可用表达式

eval 在当前基本块退出时仍然可用的表达式

eval 就是离开当前基本块的仍然可用的表达式,就是看右侧的部分.像 B1 这里右边的几个都算是,虽然B1 中左侧对于 c d 都做了定值,但是是先定值后使用,所以后面的使用的表达式仍然可用.但是对于 B2 这里,这里的 c 的定值和使用在一起,所以 c\*2 被计算出来之后 c 又被重新定值了,所以 c*2 就不再是可用的表达式了.

$out[i] = EVAL[i] \cup (in[i] - KILL[i])$

所有被计算出来的 + (进入基本块时就存在 且 没有被杀死的)

$in[i] = \bigcap\limits_{j \in Pred(i)} out[j]$

只有一个表达式在所有前驱基本块的出口处**都可用**,那么它在进入该基本块时才是可用的, 所以路径组合运算符是**交集**
