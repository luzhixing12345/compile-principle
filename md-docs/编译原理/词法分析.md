
# 词法分析

> 前面两章的内容有一些抽象, 可能读者也不清楚到底可以利用编译原理的知识完成哪些任务, 在本章中我们可以利用词法分析来做一些简单的小程序 
>
> 相信读者应该了解或使用过正则表达式, 本章我们也将完成一个很简答的正则表达式解释器

## 基本概念

词法分析是编译的第一阶段.词法分析器的主要任务是读入源程序的输人字符、将它们组成**词素(token)**,生成并输出一个词法单元序列,每个词法单元对应于一个词素.这个词法单元序列会被输出到语法分析器进行语法分析.

词法分析器通常还要和**符号表**进行交互.当词法分析器发现了一个标识符的词素时,它要将这个词素添加到符号表中.在某些情况下,词法分析器会从符号表中读取有关标识符种类的信息,以确定向语法分析器传送哪个词法单元.

![20230704101214](https://raw.githubusercontent.com/learner-lu/picbed/master/20230704101214.png)

词法分析器在编译器中负责读取源程序,因此它还会完成一些识别词素之外的其他任务, 比如:

- 过滤掉源程序中的注释和空白(空格、换行符、制表符以及在输人中用于分隔词法单元的其他字符)

  绝大多数文法是允许程序中插入任意数量的空行, 空白等字符的, 对于编译器/解释器来说这些是不需要的, 但是对于比如说语法高亮工具, lint工具, 格式化工具这些也是需要被考虑的

  对于一些特殊的文法, 比如 python 缩进, Makefile 要求的制表符\t

- 将编译器生成的错误消息与源程序的位置联系起来.例如,词法分析器可以负责记录遇到的换行符的个数,以便给每个出错消息赋予一个行号.在某些编译器中,词法分析器会建立源程序的一个拷贝,并将出错消息插入到适当位置.如果源程序使用了一个宏预处理器,则宏的扩展也可以由词法分析器完成.

  在编译阶段出现错误时, 大多数情况下编译器都会提供一个非常友好的报错信息, 定位到哪一行那一列, 甚至会在终端中使用彩色输出

  ![20230704102022](https://raw.githubusercontent.com/learner-lu/picbed/master/20230704102022.png)

  > 大多数静态分析工具已经可以做到在编写代码时提示编译错误的位置, 至少可以避免一些低级的错误

**将词法分析和语法分析分离**最重要的考虑是**简化编译器的设计**. 例如,如果一个语法分析器必须把空白符和注释当作语法单元进行处理,那么它就会比那些假设空白和注释已经被词法分析器过滤掉的处理器复杂得多.如果我们正在设计一个新的语言,将词法和语法分开考虑有助于我们得到一个更加清晰的语言设计方案.

比如下面这一段C代码, 如果做语法处理时还需要考虑注释的位置那复杂度直接提升了一个档次

```c
// 我
int f(int x) { // 可以
    // 在
    int count = 10; // 这么多
    count = x + count;
} // 地方
// 加入注释
```

在讨论词法分析的时候我们经常会使用三个相关的术语

- **词法单元**: 指描述某些字符序列的一个抽象表示, 比如前文提到的 expression, statement(stmt), factor, 或者数字 number, id, 也可以是一些关键字 if else for
- **模式**: 指构成一个词法单元的词素可能具有的形式, 对于关键字它的模式就是关键字if这个序列, 它也可能是一个很复杂的结构, 比如对于number是 `\d+`, 对于字符串是 `".*?"`, 对于变量名或函数名, 是字母或下划线开头 + 字母/数字/下划线的组合

  > 这里的举例的模式并不是最准确的定义, 比如数字还要考虑小数,科学计数; 字符串考虑中间的转义字符, 变量名函数名可能在有的编程语言比如 python 中支持中文, 这里只是一个简单的例子

- **词素(token)**: 指源程序中的一个字符序列, 它和某个词法单元的模式匹配, 并被词法分析器识别为该词法单元的一个实例. 比如 `int x = 100`, int 被识别为一个关键字`int`, x 被识别为一个变量`id`, 100 被识别为一个数字 `number`

比如对于如下的C代码段

```c
float limitedSquare(x){float x;
  /* returns x-squared, nut never more than 100 */
  return (x <= -10.0 || x >= 10.0) ? 100 : x*x;
}
```

其最后会被词法分析器分解为如下的一些词素, 注释会被忽略

```txt
<float> <id, limitedSquaare> <(> <id, x> <)> <{>
  <float> <id, x>
  <return> <(> <id, x> <op,"<="> <num, -10.0> <op, "||"> <id, x> <op, ">="> <num, 10.0> <)> <op, "?"> <num, 100> <op, ":"> <id, x> <op, "*"> <id, x>
<}>
```

## 错误处理

如果没有其他组件的帮助,词法分析器很难发现源代码中的错误.比如, 对于下面的 C 程序片断

```
fi(a == f(x))
```

第一次遇到fi时,它无法指出fi究竟是关键字if的误写还是一个未声明的函数标识符.由于fi是标识符id的一个合法词素,因此词法分析器必须向语法分析器返回这个id词法单元,而让编译器的另一个阶段(在这个例子里是语法分析器)去处理这个因为字母颠倒而引起的错误.

然而,假设出现所有词法单元的模式都无法和剩余输入的某个前缀相匹配的情况,此时词法分析器就不能继续处理输入.当出现这种情况时,最简单的错误恢复策略是"**恐慌模式**"恢复.恐慌模式的主要思想是在错误发生后尽快恢复解析过程,以便继续对后续的代码进行分析.它通常会尝试跳过一些输入,直到找到一个能够作为恢复点的标记.这个标记可以是一个特定的词法单元,也可以是一个预定的标记集合.

> 恐慌模式通常用于词法分析器的简化版本,如手写的递归下降分析器.对于使用基于自动机的词法分析器(如有限状态自动机)的现代编译器,通常会使用更复杂的错误恢复技术,如同步标记和错误修复模式,以提供更准确和可控的错误恢复能力

现代编译器在词法分析阶段采用了多种错误恢复策略,以下是一些常见的策略, 当然很多都是需要配合语法分析来进行的

- 同步标记(Synchronized Token):当词法分析器遇到错误时,它可以跳过一些词法单元,直到找到一个预期的标记,然后继续分析.这种策略可以通过事先定义一组同步标记来实现,词法分析器在发现错误后尝试跳过词法单元,直到遇到其中一个同步标记.
- 删除或插入:在遇到错误时,词法分析器可以尝试删除或插入一些字符或词法单元,以继续解析源代码.例如,如果发现多余的字符,可以删除这些字符并继续解析后面的代码.如果缺少某个关键字或标识符,可以插入相应的词法单元并继续解析.
- 错误修复模式(Error Repair Mode):这是一种基于语法的错误恢复策略.当词法分析器遇到错误时,它可以切换到错误修复模式,试图找到一个合适的位置继续解析.这种模式通常与语法分析器结合使用,通过调整输入流中的词法单元顺序或插入/删除词法单元来尝试修复错误.
- 错误优先级(Error Precedence):不同类型的错误可能有不同的优先级.词法分析器可以根据错误的优先级来选择合适的恢复策略.例如,关键错误可能需要立即报告,而一些次要的错误可以在后续处理中进行恢复.
- 局部回滚(Local Backtracking):当遇到错误时,词法分析器可以回退到之前的一个合理状态,并重新尝试解析.这种策略可以在一定程度上消除错误,并继续解析后面的代码.

## 缓冲区

源程序读人虽然简单,却很重要.由于我们常常需要查看-个词素之后的若干字符才能够确定

在实践中,很多情况下我们的确需要至少向前看一个字符.比如

- 只有读取到一个非字母或数字的字符之后才能确定我们已经到达一个标识符的末尾,因此这个字符不是id的词素的一部分.
- 在C语言中,像–、=或<这样的单字符运算符也有可能是->、==或<=这样的双字符运算符的开始字符.

因此,我们将介绍--种双缓冲区方案,这种方案能够安全地处理向前看多个符号的问题.然后我们将考虑一种改进方法.这种方法使用"哨兵标记"来节约用于检查缓冲区末端的时间.

我们维护两个缓冲区, 每个缓冲区的容量都是N个字符,通常N是一个磁盘块的大小,如4096字节.我们可以使用系统读取命令一次将N个字符读人到缓冲区中,而不是每读入一个字符调用一次系统读取命令.如果输入文件中的剩余字符不足N个,那么就会有一个特殊字符(用 EOF 表示)来标记源文件的结束.

程序为输人维护了两个指针:

- lexemeBegin指针:该指针指向当前词素的开始处.当前我们正试图确定这个词素的结尾.
- forward指针:它一直向前扫描,直到发现某个模式被匹配为止.

一旦确定了下一个词素,forward指针将指向该词素结尾的字符.词法分析器将这个词素作为某个返回给语法分析器的词法单元的属性值记录下来.然后使lexemeBegin 指针指向刚刚找到的词素之后的第一个字符

将forward指针前移要求我们首先检查是否已经到达某个缓冲区的末尾.如果是,我们必须将N个新字符读到另一个缓冲区中,且将forward 指针指向这个新载人字符的缓冲区的头部.只要我们从不需要越过实际的词素向前看很远,以至于这个词素的长度加上我们向前看的距离大于N,我们就决不会在识别这个词素之前覆盖掉这个尚在缓冲区中的词素.

但我们注意到每次向前移动forward指针时,我们都必须检查是否到达了缓冲区的末尾.若是,那么我们必须加载另一个缓冲区.因此每读入一个字符,我们需要做两次测试:一次是检查是否到达缓冲区的末尾,另一次是确定读入的字符是什么(后者可能是一个多路分支选择语句).如果我们扩展每个缓冲区,使它们在末尾包含一个"哨兵"(sentinel)字符,我们就可以把对缓冲区末端的测试和对当前字符的测试合二为一.这个哨兵字符必须是-个不会在源程序中出现的特殊字符,一个自然的选择就是字符 EOF. 其伪代码如下所示

![20230704143124](https://raw.githubusercontent.com/learner-lu/picbed/master/20230704143124.png)

> 在大多数现代程序设计语言中,词素很短,向前看一到两个字符就能够确定一个词素,所以数千字节大小的缓冲区就已经足够了.但是仍然存在一些风险.比如,如果字符串包含很多行,那么我们就有可能面临**单个词素的长度超过N的情况**.为了避免长字符串引起的问题,我们可以把它们看作不同组成部分的连接,每个组成部分对应于该字符串的一行.比如,在Java语言中,人们习惯于将一个字符串写成多个部分,每个部分占一行,并在每个部分的结尾加上运算符+,将它们连接起来.
>
> 当需要向前看任意多个字符时,就会出现一个更加严重的问题.比如,像PL/I这样的语言没有将关键字作为保留字来处理,也就是说,你可以使用一个和某个关键字(比如 DE-CLARE)同名的标识符.当词法分析器处理以DECLARE(ARG1,ARG2,……)开头的PL/I程序的文本时,它不能确定DECLARE 究竞是一个关键字(此时后面的ARG1等是被声明的变量),还是一个带有参数的过程名.因为这个原因,大多数现代程序设计语言都保留关键字.然而,如果不保留关键字,我们可以把像DECLARE这样的关键字当作一个二义性的标识符,**由语法分析器来解决这个问题.此时语法分析器就需要在符号表中杳询有关信息**.



## 词法单元的规约

<!-- 

## LL(1)文法

什么是LL1文法?

- 第一个L代表从左至右
- 第二个L代表产生最左推导
- 1代表每一步中只需要向前看一个输入符号就可以决定语法分析动作

之前我们提到了如何计算first集和follow集,既然我们已经知道了在某一状态的开头的字符都是什么,后面跟着字符都可能是什么,那么我们就可以做出预测分析.

由此引出了`可选集-SELECT集`的概念


SELECT集是指选用该产生式时的输入符号的集合


SELECT集的求法也比较简单

- 当产生式非空时,将首终结符加入SELECT集中,如果首字符是非终结符那么将该非终结符的first集加入SELECT集中
- 当产生式为空时,将follow集加入SELECT集中


这里值得注意的一点是,现在得到的文法很有可能是多个 | 连接起来的,在计算SELECT集的时候我们需要把它们都拆开,
比如 A -> aBc | ST | c,应该分解为 A->aBc,A->ST,A->c. 在分别计算它们的SELECT(A->aBc),SELECT(A->ST),SELECT(A->c)

first集和SELECT集中是可以有ε的,只有follow集中没有ε,应该说是没有出现的必要.



对于之前的例子



```txt
S -> (L) | a
L -> SL'
L' -> ,SL' | ε
```



|first集|元素|follow集|元素|
|:--:|:--:|:--:|:--:|
|first(S)|{(,a}|follow(S)|{$,`,`,)}|
|first(L)|{(,a}|follow(L)|{$,)}|
|first(L')|{`,`,ε}|follow(L')|{$,)}|


记得拆开 | 哦~


|SELECT|ITEM|
|:--:|:--:|
|SELECT(S->(L))|{(}|
|SELECT(S->a)|{a}|
|SELECT(L->SL')|{(,a}|
|SELECT(L'->,SL')|{,}|
|SELECT(L'->ε)|{$,)}|

对于具有相同左部的SELECT集,只要它们不相交,那么我们可以根据它SELECT集中的元素唯一的选择一个产生式由于推断,这样就避免了回溯,这就是LL1文法的优势.

这样我们就得到了一个表格,我们可以把它画出来


横坐标中的输入符号就是所有出现在SELECT集后面的元素
纵坐标就是所有的左部的非终结符


|非终结符|(|)|,|a|$|
|:--:|:--:|:--:|:--:|:--:|:--:|
|S|S->(L)|||S->a||
|L|L->SL'|L->SL'|||
|L'||L'->ε|L'->,SL'||L'->ε|


那么这个分析表应该怎么用呢


我们不妨先来做一道题,我会将我的解答放在下面,不过建议你先独立做完这道题再看

![20220428201954](https://raw.githubusercontent.com/learner-lu/picbed/master/20220428201954.png)

1. 试写出 ¬(a→a)$ 的一个最左推导

   ```txt
   F -> ¬F
   F -> ¬(F)
   F -> ¬(F→F)
   F -> ¬(a→F)
   F -> ¬(a→a)
   ```

2. 消除左递归和左公因子

   ```txt
   F -> ¬FT | (F)T | aT
   T -> →FT | ε
   ```

3. 求first集 follow集

   |first|ITEM|follow|ITEM|
   |:--:|:--:|:--:|:--:|
   |first(F)|{¬,(,a}|follow(F)|{$,),→}|
   |first(T)|{→,ε}|follow(T)|{$,),→}|

4. LL1分析表

   |SELECT|ITEM|
   |:--:|:--:|
   |SELECT(F->¬FT)|{¬}|
   |SELECT(F->(F)T)|{(}|
   |SELECT(F->aT)|{a}|
   |SELECT(T->→FT)|{→}|
   |SELECT(T->ε)|{$,),→}|

   |非终结符|¬|(|a|$|)|→|
   |:--:|:--:|:--:|:--:|:--:|:--:|:--:|
   |F|F->¬FT|F->(F)T|F->aT|
   |T||T->ε|T->ε|T->ε|T->ε|T->→FT\|ε|

   当输入为→且非终结符为T时,存在两个产生式,SELECT(T->→FT)与SELECT(T->ε)存在交集.所以不是LL1文法

5. ¬(a→a)的推导过程

   
   推导过程就是一个根据分析表一步步解析,消减的过程,如下
   

   |剩余串|分析栈|分析动作|
   |:--:|:--:|:--:|
   |¬(a→a)$|F$|F->¬FT|
   |¬(a→a)$|¬FT$||
   |(a→a)$|FT$|F->(F)T|
   |(a→a)$|(F)TT$||
   |a→a)$|F)TT$|F->aT|
   |a→a)$|aT)TT$||
   |→a)$|T)TT$|T->→FT|
   |→a)$|→FT)TT$||
   |a)$|FT)TT$|F->aT|
   |a)$|aTT)TT$||
   |)$|TT)TT$|T->ε|
   |)$|T)TT$|T->ε|
   |)$|)TT$||
   |$|TT$|T->ε|
   |$|T$|T->ε|
   |$|$|| -->

