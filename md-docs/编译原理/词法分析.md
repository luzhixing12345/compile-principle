
# 词法分析

## 什么是左递归

例 1: 假设有如下文法,用于表示算术运算的匹配.

```txt
E -> E + T | E - T | T
T -> T * F | T / F | F
F -> (E) | id
```

如果使用最左推导匹配 `1+2*3`, 虽然我们很容易看出来应该如何匹配, 但是由于最左推导一定会选择匹配的第一个产生式进行分解

所以分解的结果如下

```
E->E+T
E->E+T+T
E->E+...+T+T
```

这种分解永无止境,直到栈空间溢出程序退出,颇有循环递归没有终止条件无限递归调用下去的感觉,由于语法分析是从左到右依次进行的,所以也被成为**左递归**

考虑到我们需要编写程序来帮助我们执行语法分析的过程,我们需要**消除左递归以避免递归的爆栈**, 这样程序就可以根据当前终结符来判断当前的推导式是否合理,如果不合理就选下一个推导式,如果没有可选的推导式了那就回退到上一步,选择下一个推导式再推导.

消除左递归的意义就在于防止程序进入死递归,即产生式的最左侧一定不是与它相同的非终结符.

### 直接左递归

直接左递归即 A->Aα | β,该文法可以生成的字符串为 β,βα,βαα...

即最后推导的结果为 β(α)^*

所以该文法的等价文法为

A -> β A'

A' -> α A' | ε

所以我们可以得到一个通用的消除直接左递归的方法,将 A 后面的元素看作α,将与之并列的看作β,该推导式就可以推广

对于例 1:

```txt
E -> E + T | E - T | T
T -> T * F | T / F | F
F -> (E) | id
```

我们将相同符号A之后的全部看作α, 不包含的看作β. 上式可以转化为如下的形式

```txt
E -> TE'
E' -> +TE'|-TE'|ε

T -> FT'
T' -> *FT'|/FT'|ε

F -> (E) | id
```

如果直接左递归的部分十分复杂, 多个α和β都出现了

P -> Pα1 | Pα2 | Pαn | β1 | β2 | βm

那么实际上的消解式仍然不变, 替换掉直接左递归的符号P为P',然后构建P'的产生式

- P -> β1P' | β2P' | βmP'    
- P'-> α1P' | α2P' | αnP' | ε

### 间接左递归

间接左递归就是推导式的最左侧是一个非终结符,但是这个非终结符的推导式的首字符还是这个字符

例 2:

```txt
S -> Aa | b
A -> Ac | Sd | ε
```

`S -> Aa -> Sda` 还是存在左递归

解决间接左递归的方法也十分简单,就是带入: 将存在间接左递归的式子带入,即将 S 带入第二个式子

```txt
A -> Ac | (Aa|b)d | ε
```

带入之后由于 S 本身存在两个候选式,所以还需要展开

```txt
A -> Ac | Aad | bd | ε
```

再来消除直接左递归

```txt
A -> bdA' | ε
A' -> cA' | adA' | ε
```

---

实际上还可能出现一些更为复杂的情况

```txt
A -> BD
B -> CA
C -> ε
D -> a
```

上方的文法其中C由于可以推导ε,所以实际上也会产生间接左递归. 也就是说如果首字符的first集中包含ε,那么也要考虑

---

### 消除左公因子

我们再来做一道题

例 3:

S -> SS+ | SS* | a

很显然题目中存在左递归,我们先消除左递归

```txt
S -> aS'
S' -> S+S' | S*S' | ε
```

这时我们注意到一个问题,虽然消除之后的式子不存在左递归了,但是第二行出现了 `S+S'`和 `S*S'`两个开头字符相同的候选式,这虽然不会造成左递归的死循环,但是我们显然也不希望两个推导式具有完全相同的公共前缀

1. 我们希望每一个推导式具有独立的特征,这样方便我们用眼睛直接观察.
2. 对于编程来说, 相同的前缀符号不利于应该选择哪一个作为推导式,如果选择错误需要回溯
3. 用眼睛观察可以直接看到后面跟的是什么,相当于预判了后面的符号. 但是编程解决问题是无法接受回溯的,非常不利于计算效率,故而我们希望消除左公因子

消除左公因子的方法也十分的简单,就是类似于乘法中的提取公因式

左公因子是 S,所以我们可以提出 S,将两个候选式后面不同的部分单独提出来放到下一级

```txt
S -> aS'
S' -> ST | ε
T -> +S' | *S'
```

现在的文法就是消除左递归和消除左公因子之后的式子了!

## 执行顺序

上文我们提到的顺序是 `直接左递归`, `间接左递归`, `左公因子`

实际上代码实现上的消解顺序应该是, `间接左递归`, `直接左递归`, `左公因子`

这是因为**间接左递归的消除采用的是带入展开, 所以会带来新的直接左递归的出现**

三者都会创造文法中新的非终结符, 且前两者都可能会带来左公因子的出现.

此外左公因子可能会存在多个公共前缀, 比如下面的文法

```txt
S -> T + A | T + B | T - A
```

这里可以看到 `T` 是第一个左公因子, 但消除之后还会出现 `+` 的左公因子. 所以全部消除的结果为

```txt
S -> TC
C -> +D | -A
D -> A | B
```

## 自顶向下和递归下降分析

我们现在使用的文法的推导方式是自顶向下的,它从语法分析树的根节点开始依次创建各个结点.自顶向下的语法分析也可以看作是寻找输入串的最左推导的过程

自顶向下语法分析的关键就是确定一个非终结符 A 到底应该应用哪个产生式,因为一旦选择了某一个 A 的产生式,接下来就会将产生式中的终结符与输入相匹配.

目前我们使用的匹配方法是 `递归下降语法分析`,也就是俗称的递归遍历所有 A 的产生式,如果满足了就递归结束返回找下一个,如果没满足就接着找下一个.也是最原始原朴素的一种匹配方式.

但是这样可能会存在一个小问题,比如说存在一个如下的复杂文法

```txt
S -> A+B+C | D+E+F
A -> E*G+Q | B*S
D -> W+Q-T | S+Q+A
...

```

当然,为了描述其不当之处这个文法似乎有些过于复杂了...

不过从中我们可以看出来,如果说文法很复杂,假如说我们要推导的式子是 `2+3*6-1`,这时`2`作为该串的第一个终结符进行判断. 递归下降分析会依次判断候选式的首字符是否满足,当无法直接判断时(比如候选式的首字符是一个非终结符),就继续递归,再判断,再判断.如果递归出来发现没有候选式满足,那还得再回到上层,依次判断下一个候选式,这显然对于文法复杂的语言来说这会严重影响效率.

况且更致命的一点的,你前面的字符都快速的成功匹配了,但是后面突然发现一个字符没有匹配,这时候你不得不疯狂回退,再重新选择候选式,再判断,这种耗时就更加可怕了.**回溯的耗时**是我们需要解决的一个问题.

造成这个问题的 **根本原因** 是因为 不确定当前文法的非终结符应该选择什么 以及 应该选择哪个产生式

我们希望能够找到一个快速的匹配方式,比如说看到了输入是 `(`,我就是知道要匹配 `S -> A+B+C` 然后 `A-> B*S` ... 直接就能一气呵成完全不需要回溯,更好的情况就是我能根据这个文法建立一个表格,对于输入的一个字符,我能通过查表就可以知道应该怎么匹配,这样的效率显然要高得多得多.

## 预测分析法

对于某些文法,我们可以构造出向前看 K 个输入符号的预测分析器,还是刚才那个例子`2+3*6-1`,也就是说我现在的输入符号是`2`,我可以看到向下的 K 个输入.

原理就是我们可以从文法中提取一些规则,然后我们还可以根据输入的字符串预先了解到要输入的形式是什么样子的,这样我们就可以避免回溯判断,直接一步到位选择非终结符的产生式

这种方式就称为`预测分析法`,预测分析法从文法的开始符号出发,在每一步推导过程中根据当前句型的 `最左非终结符A` 和 `当前输入符号a`,选择正确的 A 产生式.

为了保证分析的准确性,**选出的候选式一定是唯一的**, 这也就是为什么我们要先消除左递归和左公因子

怎么预测呢? 其实很简单,就是看**后面能跟什么** 以及 **跟的又是什么**.

比如说有如下文法

```txt
S -> aBC
B -> bC | dB | ε
C -> c | a
```

那我们就可以知道,如果现在串的状态(暂且用"状态"一词表示)是`S`,那么后面只能跟`a`,其他的都是不正确的. 如果检测到`a`了,那状态就变成了`B`,在下一个字符就应该是 B 状态的开头都能是什么字符,因为开头的字符就是`a`后面应该跟着的,B 开头可以是 `b`和`d`,如果是 b 那就是选择 bC,d 就是 dB. 但我们注意到 B 同时也可能为空,所以我们也应该考虑 C 开头字符.

同时我们也应该考虑一个状态的结尾字符都可以是什么,如果这个状态后面可以跟 a|b|ε,但是预测发现下一个字符是 d,那我们就直接选择 ε,把判断交给下一个非终结符.

上文提到的 `开头能是什么字符` 和 `后面能跟什么字符` 就是 FIRST 集和 FOLLOW 集

## first集

first集的求法比较简单, 就是对于每一条产生式 `A -> XYZ` 依次判断其右侧的推导式 `XYZ`

1. 首先判断出那些是终结符,那些是非终结符
2. 观察右侧的推导式 `XYZ` 
   
   - 如果第一个字符 `X` 是一个终结符, 那么将 `X` 加入 `A` 的first集, **结束**
   - 如果 `X` 是一个非终结符, 那么将非终结符 `X` 的first集的**所有除ε以外的元素**加入到 `A` 的first集
     - 如果 `X` 中包含ε, 则说明`X`仍可能为空,继续往下判断 `Y`
       - 如果该产生式右侧的最后一个字符 `Z` 并且 `Z` 中仍然包含ε, 则将ε 加入到 `A` 的first集, **结束**
     - 如果 `X` 中不包含ε, **结束**

例 4:

```txt
S -> aS'
S'-> ST | ε
T -> +S' | *S'
```

我们可以求出如下 FIRST 集

| FIRST 集  |       元素        |
| :-------: | :---------------: |
| FIRST(S)  |        {a}        |
| FIRST(S') | {ε,a} |
| FIRST(T)  |      {+,\*}       |

例 5:

```txt
S -> (L)|a
L -> L,S | S
```

先消除左递归,得到

```txt
S -> (L) | a
L -> SL'
L'-> ,SL' | ε
```

然后再计算 FIRST 集

| FIRST 集  |  元素   |
| :-------: | :-----: |
| FIRST(S)  |  {(,a}  |
| FIRST(L)  |  {(,a}  |
| FIRST(L') | {`,`,ε} |

例 7: 例 1 已经消除左递归的式子,略微比之前的复杂一些

```txt
E -> TE'
E' -> +TE'|-TE'|ε
T -> FT'
T' -> *FT'|/FT'|ε
F -> (E) | id
```

| FIRST 集  |   元素   |
| :-------: | :------: |
| FIRST(E)  |  {(,id}  |
| FIRST(E') | {+,-,ε}  |
| FIRST(T)  |  {(,id}  |
| FIRST(T') | {\*,/,ε} |
| FIRST(F)  |  {(,id}  |

如果真的计算 FIRST 集的时候就会发现当我们发现 E 的 FIRST 集元素应该是 T 的 FIRST 集元素,但是现在 T 的 FIRST 集中还没有元素,只有当后面 T 的 FIRST 集更新之后,才能在回过来更新 E 的 FIRST 集.

从代码角度看的话就是一个循环,直到一轮结束之后所有 FIRST 集都没有更新,那么结束循环,否则再次查看有没有需要更新的 FIRST 集

这一点有需要注意, FIRST集虽然只看右侧产生式的首字符,但是还需要注意当这个首字符是非终结符且包含 `ε` 的时候, 还应该继续往下看

## follow 集

FIRST 集和 FOLLOW 集通常是一起出现一起考,FOLLOW 集的计算和 FIRST 集密不可分,**我们需要先计算所有元素的 FIRST 集之后才能计算 FOLLOW 集**

FOLLOW 集: 可能在某个句型中紧跟在 A 后面的终结符 a 的集合,如果 A 是某个句型的最右符号则把$也加入 FOLLOW 集

对于产生式 `A -> BCDEF`

1. 将 $ 加入到起始元素 S 的follow集中

   这里要注意, $ 只加入到起始元素的follow集中, 表示结尾. 这里的 `A -> BCDF` 只是众多的产生式中的一个, 并不是把 $ 加入到每个产生式左侧的A中!

2. 先观察右侧的 `BCDEF`, 顺序观察遍历
   1. 如果是 `B` 是终结符, 下一个
   2. 如果 `B` 是非终结符
      1. 把 `C` 的first集加入到 `B` 的follow集中, 因为C在B后面,所以B后面肯定可以跟C的开头的字符
      2. 如果 `C` 的first集中包含 ε, 那么接着往下看 `D`, 直到没有 ε. 如果到结尾F了还存在ε, 那么把ε加入到B的first集中, **结束**
   3. 接着看C D E
   4. 如果产生式的结尾 `F` 是一个非终结符, 那么把 `A` 的follow集加入到 `F` 的follow集中

      注意这里一定不要搞反了! 是把 A 的follow加入到 F的follow中

例 5:

```txt
S -> (L) | a
L -> SL'
L' -> ,SL' | ε
```

这里的 FOLLOW 集的求法分为三步:

1. 先观察某一个非终结符后面有没有直接跟了终结符, 比如 L),那么就把 `)` 加入到 FOLLOW(L)
2. 再观察两个非终结符连在一起的, 比如 SL',这种就是 S 后面跟的就应该是 L'的开头,所以把 FIRST(L')加入到 FOLLOW(S)
3. 最后一种就是观察一个推导是不是以非终结符结尾, 比如 `L -> SL'`,那么能跟在 L 后面的一定也能跟在 L'后面,FOLLOW(L)加入到 FOLLOW(L')中.


这里要重点说明一下: `L -> SL'` **是把 FOLLOW(L)加入到 FOLLOW(L')**,**但是不能把 FOLLOW(L')加入到 FOLLOW(L)中**
如果说你后续向 FOLLOW(L)中追加了其他元素,FOLLOW(L')也应该在下一轮中更新

> 当然如果不是写代码而是做题的话就留个心眼记得更新就好了

FOLLOW 集的定义就是找到能跟在某一非终结符后面的所有终结符,正是因为 L 具有一个产生式 `L -> SL'`,所以能跟在 L 的 FOLLOW 集中的元素一定是 FOLLOW(L')中的元素,后续向 FOLLOW(L)中追加的元素也应该补充到 FOLLOW(L')中

这个式子的左侧非终结符是 L,也就是说现在我们考虑的是 L 对其产生式的影响,能跟在 L 后面的一定可以跟在其产生式后面,所以 FOLLOW(L)应该加入到产生式结尾的非终结符的 FOLLOW 集中.

我举一个实际一些的例子来理解一下 FOLLOW 集的作用,假设有如下文法

```txt
A -> 2CB
B -> 1B | ε
C -> 3C4 | ε
```

可以用眼睛看一看,这个式子表示的含义是推导一个类似 `23^n4^n1^m` 的字符串,开头是 2,结尾是一堆 1,中间是数量相同的 3 和 4

先求 FIRST 集

|  FIRST   | ITEM  |
| :------: | :---: |
| FIRST(A) |  {2}  |
| FIRST(B) | {1,ε} |
| FIRST(C) | {3,ε} |

FOLLOW(C)很好求

- C->3C4|ε 可以得到 FOLLOW(C) = {4}
- A->2CB 可以得到 FOLLOW(C) = {4} + FIRST(B)-ε = {4,1}

所以最后 FOLLOW(C) = {$,4,1},表示如果现在的状态是 C,那么后面跟着的不是 1 就是 4

因为 B -> ε,A -> 2CB,所以 FOLLOW(A)加入到 FOLLOW(C),这是合理的,虽然没啥用

但是你不能把 FOLLOW(C)加入到 FOLLOW(A)里,A 就是最开始的推导串,哪里有什么其他非终结符作为 FOLLOW 呢?

**所以 FOLLOW 集的添加是不可逆的**,将 FOLLOW(A)加入到 FOLLOW(C)中


最后一个补充的就是和 FIRST 集的推导中的提示类似,如果某一个推导可能推导出空串,那么就要注意如果它是空的情况

如果 FIRST 集中含有 ε,那么我们不把 ε 加入到 FOLLOW 集.FOLLOW 集都是不含 ε 的,因为就算 ε 可以跟在一个非终结符后面,这也没啥意义.

拉的有点远了我们回到这一题


```txt
S -> (L) | a
L -> SL'
L' -> ,SL' | ε
```

| FIRST 集  |  元素   | FOLLOW 集  |   元素    |
| :-------: | :-----: | :--------: | :-------: |
| FIRST(S)  |  {(,a}  | FOLLOW(S)  | {$,`,`,)} |
| FIRST(L)  |  {(,a}  | FOLLOW(L)  |   {$,)}   |
| FIRST(L') | {`,`,ε} | FOLLOW(L') |   {$,)}   |

例 7: 例 1 已经消除左递归的式子,略微比之前的复杂一些

```txt
E -> TE'
E' -> +TE'|-TE'|ε
T -> FT'
T' -> *FT'|/FT'|ε
F -> (E) | id
```

| FIRST 集  |   元素   | FOLLOW 集  |     元素     |
| :-------: | :------: | :--------: | :----------: |
| FIRST(E)  |  {(,id}  | FOLLOW(E)  |    {$,)}     |
| FIRST(E') | {+,-,ε}  | FOLLOW(E') |    {$,)}     |
| FIRST(T)  |  {(,id}  | FOLLOW(T)  |   {$,+,-}    |
| FIRST(T') | {\*,/,ε} | FOLLOW(T') |   {$,+,-}    |
| FIRST(F)  |  {(,id}  | FOLLOW(F)  | {$,\*,/,+,-} |

> 怕我没说清楚这里再提一句解释一下

- T -> FT'
- T' -> *FT'|/FT'|ε

这两个推导式可以看出来存在 T'->ε 的产生式,所以不止有 FOLLOW(T)加入到 FOLLOW(T'),还有 FOLLOW(T)加入到 FOLLOW(F)

> 这两步都是有的,只不过说如果 FOLLOW 集元素重复会去重,没有明显变化罢了

## LL(1)文法

什么是LL1文法?

- 第一个L代表从左至右
- 第二个L代表产生最左推导
- 1代表每一步中只需要向前看一个输入符号就可以决定语法分析动作

之前我们提到了如何计算FIRST集和FOLLOW集,既然我们已经知道了在某一状态的开头的字符都是什么,后面跟着字符都可能是什么,那么我们就可以做出预测分析.

由此引出了`可选集-SELECT集`的概念


SELECT集是指选用该产生式时的输入符号的集合


SELECT集的求法也比较简单

- 当产生式非空时,将首终结符加入SELECT集中,如果首字符是非终结符那么将该非终结符的FIRST集加入SELECT集中
- 当产生式为空时,将FOLLOW集加入SELECT集中


这里值得注意的一点是,现在得到的文法很有可能是多个 | 连接起来的,在计算SELECT集的时候我们需要把它们都拆开,
比如 A -> aBc | ST | c,应该分解为 A->aBc,A->ST,A->c. 在分别计算它们的SELECT(A->aBc),SELECT(A->ST),SELECT(A->c)

FIRST集和SELECT集中是可以有ε的,只有FOLLOW集中没有ε,应该说是没有出现的必要.



对于之前的例子



```txt
S -> (L) | a
L -> SL'
L' -> ,SL' | ε
```



|FIRST集|元素|FOLLOW集|元素|
|:--:|:--:|:--:|:--:|
|FIRST(S)|{(,a}|FOLLOW(S)|{$,`,`,)}|
|FIRST(L)|{(,a}|FOLLOW(L)|{$,)}|
|FIRST(L')|{`,`,ε}|FOLLOW(L')|{$,)}|


记得拆开 | 哦~


|SELECT|ITEM|
|:--:|:--:|
|SELECT(S->(L))|{(}|
|SELECT(S->a)|{a}|
|SELECT(L->SL')|{(,a}|
|SELECT(L'->,SL')|{,}|
|SELECT(L'->ε)|{$,)}|

对于具有相同左部的SELECT集,只要它们不相交,那么我们可以根据它SELECT集中的元素唯一的选择一个产生式由于推断,这样就避免了回溯,这就是LL1文法的优势.

这样我们就得到了一个表格,我们可以把它画出来


横坐标中的输入符号就是所有出现在SELECT集后面的元素
纵坐标就是所有的左部的非终结符


|非终结符|(|)|,|a|$|
|:--:|:--:|:--:|:--:|:--:|:--:|
|S|S->(L)|||S->a||
|L|L->SL'|L->SL'|||
|L'||L'->ε|L'->,SL'||L'->ε|


那么这个分析表应该怎么用呢


我们不妨先来做一道题,我会将我的解答放在下面,不过建议你先独立做完这道题再看

![20220428201954](https://raw.githubusercontent.com/learner-lu/picbed/master/20220428201954.png)

1. 试写出 ¬(a→a)$ 的一个最左推导

   ```txt
   F -> ¬F
   F -> ¬(F)
   F -> ¬(F→F)
   F -> ¬(a→F)
   F -> ¬(a→a)
   ```

2. 消除左递归和左公因子

   ```txt
   F -> ¬FT | (F)T | aT
   T -> →FT | ε
   ```

3. 求FIRST集 FOLLOW集

   |FIRST|ITEM|FOLLOW|ITEM|
   |:--:|:--:|:--:|:--:|
   |FIRST(F)|{¬,(,a}|FOLLOW(F)|{$,),→}|
   |FIRST(T)|{→,ε}|FOLLOW(T)|{$,),→}|

4. LL1分析表

   |SELECT|ITEM|
   |:--:|:--:|
   |SELECT(F->¬FT)|{¬}|
   |SELECT(F->(F)T)|{(}|
   |SELECT(F->aT)|{a}|
   |SELECT(T->→FT)|{→}|
   |SELECT(T->ε)|{$,),→}|

   |非终结符|¬|(|a|$|)|→|
   |:--:|:--:|:--:|:--:|:--:|:--:|:--:|
   |F|F->¬FT|F->(F)T|F->aT|
   |T||T->ε|T->ε|T->ε|T->ε|T->→FT\|ε|

   当输入为→且非终结符为T时,存在两个产生式,SELECT(T->→FT)与SELECT(T->ε)存在交集.所以不是LL1文法

5. ¬(a→a)的推导过程

   
   推导过程就是一个根据分析表一步步解析,消减的过程,如下
   

   |剩余串|分析栈|分析动作|
   |:--:|:--:|:--:|
   |¬(a→a)$|F$|F->¬FT|
   |¬(a→a)$|¬FT$||
   |(a→a)$|FT$|F->(F)T|
   |(a→a)$|(F)TT$||
   |a→a)$|F)TT$|F->aT|
   |a→a)$|aT)TT$||
   |→a)$|T)TT$|T->→FT|
   |→a)$|→FT)TT$||
   |a)$|FT)TT$|F->aT|
   |a)$|aTT)TT$||
   |)$|TT)TT$|T->ε|
   |)$|T)TT$|T->ε|
   |)$|)TT$||
   |$|TT$|T->ε|
   |$|T$|T->ε|
   |$|$||

