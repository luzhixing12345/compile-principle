<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <div class="header-navigator"><ul><li><a href="#h1-0">first-follow-select</a><ul><li><a href="#h2-1">first集</a></li></ul><ul><li><a href="#h2-2">FOLLOW 集</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">first-follow-select</h1><h2 id="h2-1">first集</h2><p>first集的求法比较简单, 就是对于每一条产生式 <code>A -&gt; XYZ</code> 依次判断其右侧的推导式 <code>XYZ</code></p><ol start="1"><li>首先判断出那些是终结符,那些是非终结符</li></ol><ol start="2"><li>观察右侧的推导式 <code>XYZ</code><ul><li>如果第一个字符 <code>X</code> 是一个终结符, 那么将 <code>X</code> 加入 <code>A</code> 的first集, <b>结束</b></li></ul><ul><li>如果 <code>X</code> 是一个非终结符, 那么将非终结符 <code>X</code> 的first集的<b>所有除ε以外的元素</b>加入到 <code>A</code> 的first集<ul><li>如果 <code>X</code> 中包含ε, 则说明<code>X</code>仍可能为空,继续往下判断 <code>Y</code><ul><li>如果该产生式右侧的最后一个字符 <code>Z</code> 并且 <code>Z</code> 中仍然包含ε, 则将ε 加入到 <code>A</code> 的first集, <b>结束</b></li></ul></li></ul><ul><li>如果 <code>X</code> 中不包含ε, <b>结束</b></li></ul></li></ul></li></ol><p>例 4:</p><pre><code class="language-txt">S -&gt; aS'
S'-&gt; ST | ε
T -&gt; +S' | *S'</code></pre><p>我们可以求出如下 FIRST 集</p><table><tr><th>FIRST 集</th><th>元素</th></tr><tr><td style="text-align:center">                FIRST(S)</td><td style="text-align:center">                {a}</td></tr><tr><td style="text-align:center">                FIRST(S')</td><td style="text-align:center">                {ε,a}</td></tr><tr><td style="text-align:center">                FIRST(T)</td><td style="text-align:center">                {+,*}</td></tr></table><p>例 5:</p><pre><code class="language-txt">S -&gt; (L)|a
L -&gt; L,S | S</code></pre><p>先消除左递归,得到</p><pre><code class="language-txt">S -&gt; (L) | a
L -&gt; SL'
L'-&gt; ,SL' | ε</code></pre><p>然后再计算 FIRST 集</p><table><tr><th>FIRST 集</th><th>元素</th></tr><tr><td style="text-align:center">                FIRST(S)</td><td style="text-align:center">                {(,a}</td></tr><tr><td style="text-align:center">                FIRST(L)</td><td style="text-align:center">                {(,a}</td></tr><tr><td style="text-align:center">                FIRST(L')</td><td style="text-align:center">                {<code>,</code>,ε}</td></tr></table><p>例 7: 例 1 已经消除左递归的式子,略微比之前的复杂一些</p><pre><code class="language-txt">E -&gt; TE'
E' -&gt; +TE'|-TE'|ε
T -&gt; FT'
T' -&gt; *FT'|/FT'|ε
F -&gt; (E) | id</code></pre><table><tr><th>FIRST 集</th><th>元素</th></tr><tr><td style="text-align:center">                FIRST(E)</td><td style="text-align:center">                {(,id}</td></tr><tr><td style="text-align:center">                FIRST(E')</td><td style="text-align:center">                {+,-,ε}</td></tr><tr><td style="text-align:center">                FIRST(T)</td><td style="text-align:center">                {(,id}</td></tr><tr><td style="text-align:center">                FIRST(T')</td><td style="text-align:center">                {*,/,ε}</td></tr><tr><td style="text-align:center">                FIRST(F)</td><td style="text-align:center">                {(,id}</td></tr></table><p>如果真的计算 FIRST 集的时候就会发现当我们发现 E 的 FIRST 集元素应该是 T 的 FIRST 集元素,但是现在 T 的 FIRST 集中还没有元素,只有当后面 T 的 FIRST 集更新之后,才能在回过来更新 E 的 FIRST 集.</p><p>从代码角度看的话就是一个循环,直到一轮结束之后所有 FIRST 集都没有更新,那么结束循环,否则再次查看有没有需要更新的 FIRST 集</p><p>这一点有需要注意, FIRST集虽然只看右侧产生式的首字符,但是还需要注意当这个首字符是非终结符且包含 <code>ε</code> 的时候, 还应该继续往下看</p><h2 id="h2-2">FOLLOW 集</h2><p>FIRST 集和 FOLLOW 集通常是一起出现一起考,FOLLOW 集的计算和 FIRST 集密不可分,<b>我们需要先计算所有元素的 FIRST 集之后才能计算 FOLLOW 集</b></p><p>FOLLOW 集: 可能在某个句型中紧跟在 A 后面的终结符 a 的集合,如果 A 是某个句型的最右符号则把$也加入 FOLLOW 集</p><p>对于产生式 <code>A -&gt; BCDEF</code></p><ol start="1"><li>将 $ 加入到起始元素 S 的follow集中<p>这里要注意, $ 只加入到起始元素的follow集中, 表示结尾. 这里的 <code>A -&gt; BCDF</code> 只是众多的产生式中的一个, 并不是把 $ 加入到每个产生式左侧的A中!</p></li></ol><ol start="2"><li>先观察右侧的 <code>BCDEF</code>, 顺序观察遍历<ol start="1"><li>如果是 <code>B</code> 是终结符, 下一个</li></ol><ol start="2"><li>如果 <code>B</code> 是非终结符<ol start="1"><li>把 <code>C</code> 的first集加入到 <code>B</code> 的follow集中, 因为C在B后面,所以B后面肯定可以跟C的开头的字符</li></ol><ol start="2"><li>如果 <code>C</code> 的first集中包含 ε, 那么接着往下看 <code>D</code>, 直到没有 ε. 如果到结尾F了还存在ε, 那么把ε加入到B的first集中, <b>结束</b></li></ol></li></ol><ol start="3"><li>接着看C D E</li></ol><ol start="4"><li>如果产生式的结尾 <code>F</code> 是一个非终结符, 那么把 <code>A</code> 的follow集加入到 <code>F</code> 的follow集中<p>注意这里一定不要搞反了! 是把 A 的follow加入到 F的follow中</p></li></ol></li></ol><p>例 5:</p><pre><code class="language-txt">S -&gt; (L) | a
L -&gt; SL'
L' -&gt; ,SL' | ε</code></pre><p>这里的 FOLLOW 集的求法分为三步:</p><ol start="1"><li>先观察某一个非终结符后面有没有直接跟了终结符, 比如 L),那么就把 <code>)</code> 加入到 FOLLOW(L)</li></ol><ol start="2"><li>再观察两个非终结符连在一起的, 比如 SL',这种就是 S 后面跟的就应该是 L'的开头,所以把 FIRST(L')加入到 FOLLOW(S)</li></ol><ol start="3"><li>最后一种就是观察一个推导是不是以非终结符结尾, 比如 <code>L -&gt; SL'</code>,那么能跟在 L 后面的一定也能跟在 L'后面,FOLLOW(L)加入到 FOLLOW(L')中.</li></ol><p>这里要重点说明一下: <code>L -&gt; SL'</code> <b>是把 FOLLOW(L)加入到 FOLLOW(L')</b>,<b>但是不能把 FOLLOW(L')加入到 FOLLOW(L)中</b>如果说你后续向 FOLLOW(L)中追加了其他元素,FOLLOW(L')也应该在下一轮中更新</p><blockquote><p>当然如果不是写代码而是做题的话就留个心眼记得更新就好了</p></blockquote><p>FOLLOW 集的定义就是找到能跟在某一非终结符后面的所有终结符,正是因为 L 具有一个产生式 <code>L -&gt; SL'</code>,所以能跟在 L 的 FOLLOW 集中的元素一定是 FOLLOW(L')中的元素,后续向 FOLLOW(L)中追加的元素也应该补充到 FOLLOW(L')中</p><p>这个式子的左侧非终结符是 L,也就是说现在我们考虑的是 L 对其产生式的影响,能跟在 L 后面的一定可以跟在其产生式后面,所以 FOLLOW(L)应该加入到产生式结尾的非终结符的 FOLLOW 集中.</p><p>我举一个实际一些的例子来理解一下 FOLLOW 集的作用,假设有如下文法</p><pre><code class="language-txt">A -&gt; 2CB
B -&gt; 1B | ε
C -&gt; 3C4 | ε</code></pre><p>可以用眼睛看一看,这个式子表示的含义是推导一个类似 <code>23^n4^n1^m</code> 的字符串,开头是 2,结尾是一堆 1,中间是数量相同的 3 和 4</p><p>先求 FIRST 集</p><table><tr><th>FIRST</th><th>ITEM</th></tr><tr><td style="text-align:center">                FIRST(A)</td><td style="text-align:center">                {2}</td></tr><tr><td style="text-align:center">                FIRST(B)</td><td style="text-align:center">                {1,ε}</td></tr><tr><td style="text-align:center">                FIRST(C)</td><td style="text-align:center">                {3,ε}</td></tr></table><p>FOLLOW(C)很好求</p><ul><li>C-&gt3C4|ε 可以得到 FOLLOW(C) = {4}</li></ul><ul><li>A-&gt2CB 可以得到 FOLLOW(C) = {4} + FIRST(B)-ε = {4,1}</li></ul><p>所以最后 FOLLOW(C) = {$,4,1},表示如果现在的状态是 C,那么后面跟着的不是 1 就是 4</p><p>因为 B -&gt ε,A -&gt 2CB,所以 FOLLOW(A)加入到 FOLLOW(C),这是合理的,虽然没啥用</p><p>但是你不能把 FOLLOW(C)加入到 FOLLOW(A)里,A 就是最开始的推导串,哪里有什么其他非终结符作为 FOLLOW 呢?</p><p><b>所以 FOLLOW 集的添加是不可逆的</b>,将 FOLLOW(A)加入到 FOLLOW(C)中</p><p>最后一个补充的就是和 FIRST 集的推导中的提示类似,如果某一个推导可能推导出空串,那么就要注意如果它是空的情况</p><p>如果 FIRST 集中含有 ε,那么我们不把 ε 加入到 FOLLOW 集.FOLLOW 集都是不含 ε 的,因为就算 ε 可以跟在一个非终结符后面,这也没啥意义.</p><p>拉的有点远了我们回到这一题</p><pre><code class="language-txt">S -&gt; (L) | a
L -&gt; SL'
L' -&gt; ,SL' | ε</code></pre><table><tr><th>FIRST 集</th><th>元素</th><th>FOLLOW 集</th><th>元素</th></tr><tr><td style="text-align:center">                FIRST(S)</td><td style="text-align:center">                {(,a}</td><td style="text-align:center">                FOLLOW(S)</td><td style="text-align:center">                {$,<code>,</code>,)}</td></tr><tr><td style="text-align:center">                FIRST(L)</td><td style="text-align:center">                {(,a}</td><td style="text-align:center">                FOLLOW(L)</td><td style="text-align:center">                {$,)}</td></tr><tr><td style="text-align:center">                FIRST(L')</td><td style="text-align:center">                {<code>,</code>,ε}</td><td style="text-align:center">                FOLLOW(L')</td><td style="text-align:center">                {$,)}</td></tr></table><p>例 7: 例 1 已经消除左递归的式子,略微比之前的复杂一些</p><pre><code class="language-txt">E -&gt; TE'
E' -&gt; +TE'|-TE'|ε
T -&gt; FT'
T' -&gt; *FT'|/FT'|ε
F -&gt; (E) | id</code></pre><table><tr><th>FIRST 集</th><th>元素</th><th>FOLLOW 集</th><th>元素</th></tr><tr><td style="text-align:center">                FIRST(E)</td><td style="text-align:center">                {(,id}</td><td style="text-align:center">                FOLLOW(E)</td><td style="text-align:center">                {$,)}</td></tr><tr><td style="text-align:center">                FIRST(E')</td><td style="text-align:center">                {+,-,ε}</td><td style="text-align:center">                FOLLOW(E')</td><td style="text-align:center">                {$,)}</td></tr><tr><td style="text-align:center">                FIRST(T)</td><td style="text-align:center">                {(,id}</td><td style="text-align:center">                FOLLOW(T)</td><td style="text-align:center">                {$,+,-}</td></tr><tr><td style="text-align:center">                FIRST(T')</td><td style="text-align:center">                {*,/,ε}</td><td style="text-align:center">                FOLLOW(T')</td><td style="text-align:center">                {$,+,-}</td></tr><tr><td style="text-align:center">                FIRST(F)</td><td style="text-align:center">                {(,id}</td><td style="text-align:center">                FOLLOW(F)</td><td style="text-align:center">                {$,*,/,+,-}</td></tr></table><blockquote><p>怕我没说清楚这里再提一句解释一下</p></blockquote><ul><li>T -&gt FT'</li></ul><ul><li>T' -&gt *FT'|/FT'|ε</li></ul><p>这两个推导式可以看出来存在 T'-&gtε 的产生式,所以不止有 FOLLOW(T)加入到 FOLLOW(T'),还有 FOLLOW(T)加入到 FOLLOW(F)</p><blockquote><p>这两步都是有的,只不过说如果 FOLLOW 集元素重复会去重,没有明显变化罢了</p></blockquote></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/消除左递归" >消除左递归</a></li></ul><ul><li><a href="../../md-docs/first-follow-select" >first-follow-select</a></li></ul><ul><li><a href="../../md-docs/LL1" >LL1</a></li></ul><ul><li><a href="../../md-docs/RE-NFA-DFA" >RE-NFA-DFA</a></li></ul><ul><li><a href="../../md-docs/使用方法" >使用方法</a></li></ul><ul><li><a href="../../编译原理/引论" >编译原理</a><ul><li><a href="../../编译原理/引论" >引论</a></li></ul><ul><li><a href="../../编译原理/简单的翻译器" >简单的翻译器</a></li></ul><ul><li><a href="../../编译原理/词法分析" >词法分析</a></li></ul><ul><li><a href="../../编译原理/语法分析" >语法分析</a></li></ul><ul><li><a href="../../编译原理/语法制导翻译" >语法制导翻译</a></li></ul><ul><li><a href="../../编译原理/中间代码生成" >中间代码生成</a></li></ul><ul><li><a href="../../编译原理/运行时环境" >运行时环境</a></li></ul><ul><li><a href="../../编译原理/后端代码生成" >后端代码生成</a></li></ul><ul><li><a href="../../编译原理/机器无关优化" >机器无关优化</a></li></ul><ul><li><a href="../../编译原理/指令级并行" >指令级并行</a></li></ul><ul><li><a href="../../编译原理/并行性和局部性优化" >并行性和局部性优化</a></li></ul><ul><li><a href="../../编译原理/过程间分析" >过程间分析</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/消除左递归","../../md-docs/LL1","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
</body>

</html>